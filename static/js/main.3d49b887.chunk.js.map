{"version":3,"sources":["components/Node/Node.js","algorithms/commonAlgorithmFunctions.js","algorithms/dijkstra.js","algorithms/visualizingFunctions.js","algorithms/A_star.js","components/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isFinish","isWall","isVisited","onMouseDown","onMouseEnter","onMouseUp","extraNameCheck","id","className","Component","getNeighbours","grid","node","maxRowIndex","length","maxColIndex","topNeighbour","bottomNeighbour","filter","checkNode","sort","n1","n2","distance","relax","currentNode","neighbour","tempDistance","cost","predecessor","visualizeAlgorithm","currentAlgorithm","START_ROW","START_COL","FINISH_ROW","FINISH_COL","startNode","finishNode","visitedNodesInOrder","queue","nodeList","i","j","push","getAllNodes","shift","console","log","Infinity","currentNeighbours","dijkstraSearch","openList","closedList","includes","total","manDistance","currentNodeInOpenList","find","aStar","shortestPath","result","backtrackShortestPath","setTimeout","document","getElementById","animateShortestPath","animateAlgorithm","PathfindingVisualizer","mousePressed","animationIsActive","canChangeGrid","grabbedStart","grabbedFinish","infoSheetRef","React","createRef","removeInfoSheet","bind","createGrid","setState","timerLists","lockInterfaceInAnimation","resetGrid","actualGrid","newGrid","getGridWithWalls","changeStartOrFinishNode","adjustedGrid","resultGrid","slice","Math","abs","recalculateManDistance","changeStart","copyGrid","algorithm","activeButton","getElementsByClassName","replace","highlightButtons","randomNumbers","randomRow1","getRandomValues","randomRow2","randomCol1","randomCol2","ok","getRandomStartFinish","cleanGrid","floor","random","current","remove","ref","onClick","reset","setAlgorithmOnClick","generateRandomMaze","map","rowIndex","nodeIndex","rowsAndCols","screen","screenWidth","offsetWidth","screenHeight","offsetHeight","calculateRowsAndCols","rows","cols","currentRow","createNode","min","max","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.3d49b887.chunk.js","sourcesContent":["import React,  {Component} from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        //The same way as in PathfindingVisualizer, extract values from props\r\n        const {\r\n            row,\r\n            col,\r\n            isStart,\r\n            isFinish,\r\n            isWall,\r\n            isVisited,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n        } = this.props;\r\n\r\n        const extraNameCheck = isStart\r\n            ? \"node-start\"\r\n            : isFinish\r\n            ? \"node-finish\"\r\n            : isWall\r\n            ? \"node-wall\"\r\n            : isVisited\r\n            ? \"node-visited\"\r\n            : \"\";\r\n        /*\r\n            We pass functions into the props for handling mouse-events,\r\n            and add these event-listener functions to the Node-component.\r\n            Each individual node will simply have a function to handle\r\n            a mouseDown, mouseEnter, or mouseUp event, such that all of them\r\n            can use their individual row-col values.\r\n        */\r\n        return (\r\n            <div\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraNameCheck}`}\r\n            isWall={isWall}\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseUp={() => onMouseUp()}\r\n            ></div>\r\n        );\r\n    }\r\n}\r\n/*\r\nconstructor(props) {\r\n        super(props);\r\n        this.state = [];\r\n    }\r\n*/","\r\nfunction getNeighbours(grid, node) {\r\n    const {row, col} = node;\r\n    const maxRowIndex = grid.length - 1;\r\n    const maxColIndex = grid[0].length - 1;\r\n\r\n    const topNeighbour = (row > 0) ? grid[row-1][col] : null;\r\n    const bottomNeighbour = (row < maxRowIndex) ? grid[row+1][col] : null;\r\n    const rightNeighbour = (col < maxColIndex) ? grid[row][col+1] : null;\r\n    const leftNeighbour = (col > 0) ? grid[row][col-1] : null;\r\n    const neighbourList = [topNeighbour, rightNeighbour, bottomNeighbour, leftNeighbour];\r\n\r\n    // Filter out null-nodes, visited nodes, wall nodes, and sort the list\r\n    // where nodes with minimal distance will appear first\r\n    const result = neighbourList\r\n        .filter(checkNode)\r\n        .sort((n1, n2) => n1.distance - n2.distance);\r\n    return result;\r\n}\r\n\r\n// Check if a node is null, visited, or a wall\r\nfunction checkNode(node) {\r\n    if (node === null) {\r\n        return false;\r\n    }\r\n    if (node.isVisited) {\r\n        return false;\r\n    }\r\n    if (node.isWall) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// Backtrack the shortest path. Must be called after dijkstraSearch\r\nfunction backtrackShortestPath (finishNode) {\r\n    const result = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode.predecessor) {\r\n        result.push(currentNode);\r\n        currentNode = currentNode.predecessor;\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n\r\nexport {\r\n    getNeighbours,\r\n    checkNode,\r\n    backtrackShortestPath,\r\n};","\r\nimport { getNeighbours } from \"./commonAlgorithmFunctions\";\r\n\r\n/*\r\nThe main idea in these algorithms will be to first implement the functions that\r\nprovide the actual solution, and then implement functions that will visualize\r\nthese solutions by altering the classname of each explored node in order to\r\ncolorize which nodes are in progress, which ones are visited, and ultimately \r\nhighlight the final path. The animation will be taken care of in\r\nPathfindingVisualizer, while we provide the actual backend of the algorithms here.\r\n*/\r\n\r\n// Dijkstra's algorithm: takes in a grid of nodes, along with start and finish,\r\n// and checks two nodes u,v if it's cheaper/more efficient to move\r\n// from node u to v instead of the path v already has.\r\n// Also updates each node with a pointer to its predecessor.\r\nfunction dijkstraSearch(grid, startNode, finishNode) {\r\n\r\n    const queue = getAllNodes(grid);\r\n    const visitedNodesInOrder = [];\r\n    \r\n    // equivalent to (queue && queue.length)\r\n    while (queue?.length) {\r\n        //debugger;\r\n        queue.sort((n1, n2) => n1.distance - n2.distance);\r\n        \r\n\r\n        \r\n        // Because of the sorting, this node is guaranteed to have the lowest distance\r\n        const currentNode = queue.shift();\r\n        //debugger;\r\n        console.log(currentNode);\r\n\r\n        // If a wall is encountered, skip the node\r\n        if (currentNode.isWall) continue;\r\n\r\n        \r\n        // If we end up here, then we are trapped, and therefore return the list of nodes\r\n        if (currentNode.distance === Infinity) {\r\n            return visitedNodesInOrder;\r\n        }\r\n        // Break if we have found the target (might delete later to calculate all-to-all)\r\n        if (currentNode === finishNode) {\r\n            return visitedNodesInOrder;\r\n        }\r\n        \r\n        // Get all neighbours of current node\r\n        const currentNeighbours = getNeighbours(grid, currentNode);\r\n        visitedNodesInOrder.push(currentNode);\r\n        // Iterate through neighbours and relax the edges\r\n        for (let neighbour of currentNeighbours) {\r\n            relax(currentNode, neighbour);\r\n        }\r\n    }\r\n}\r\n\r\n// Relax an edge between u and v:\r\n// if (u.distance + cost(go from u to v) < v.distance)\r\n// => v.distance = u.distance cost(go from u to v);\r\n// => v.predecessor = u;\r\nfunction relax(currentNode, neighbour) {\r\n    const tempDistance = currentNode.distance + neighbour.cost;\r\n        if (tempDistance < neighbour.distance) {\r\n            neighbour.distance = tempDistance;\r\n            neighbour.predecessor = currentNode;\r\n        }\r\n}\r\n\r\n// Returns a sorted list of all nodes in the grid where the sorting\r\n// is based on the distance of each node\r\nfunction getAllNodes(grid) {\r\n    const nodeList = [];\r\n    for (let i = 0; i < grid.length; i++) {\r\n        const row = grid[i];\r\n        for (let j = 0; j < row.length; j++) {\r\n            nodeList.push(row[j]);\r\n        }\r\n    }\r\n    const result = nodeList.sort((n1, n2) => n1.distance - n2.distance);\r\n    return result;\r\n}\r\n\r\nexport {dijkstraSearch, relax, getAllNodes};","import {dijkstraSearch} from \"./dijkstra.js\";\r\nimport {aStar} from \"./A_star\";\r\nimport { backtrackShortestPath } from \"./commonAlgorithmFunctions\";\r\n\r\n// Function called when a button is clicked to visualize the result of\r\n// the pathfinding algorithm. Performed by calling to other helper-functions\r\nfunction visualizeAlgorithm(grid, currentAlgorithm, START_ROW, START_COL, FINISH_ROW, FINISH_COL) {\r\n    const startNode = grid[START_ROW][START_COL];\r\n    const finishNode = grid[FINISH_ROW][FINISH_COL];\r\n\r\n    const visitedNodesInOrder = (currentAlgorithm === \"Dijkstra\") ?\r\n        dijkstraSearch(grid, startNode, finishNode) : (currentAlgorithm === \"Astar\") ?\r\n        aStar(grid, startNode, finishNode) : null; // can add more later\r\n\r\n    const shortestPath = backtrackShortestPath(finishNode);\r\n    animateAlgorithm(visitedNodesInOrder, shortestPath);\r\n    // Return the lists in case we need to use them, thus we don't have to recalculate them\r\n    return [visitedNodesInOrder, shortestPath];\r\n}\r\n\r\n/* NOTE 1\r\n    The way we animate the pathfinder-algorithm, is to have\r\n    an array of visited nodes, and create a copy of the existing\r\n    grid every time we iterate through a visited node.\r\n    This is as an external function that sets a timeout every time\r\n    a node is iterated, instead of being taken care of inside of\r\n    the render function. We iterate through all visited nodes, and\r\n    for each node, we create a copy grid, and a copy node.\r\n    We replace the existing node in the copy grid, with the\r\n    copy node that has updated its isVisited-state.\r\n    We pass in the copy grid as the new state of the React-component,\r\n    and set a timeout. Therefore, the state will update itself with\r\n    an interval of the timeout-value, which will be perceived as\r\n    individual boxes changing their layouts because every state-update\r\n    changes a single node. \r\n*/\r\n/* NOTE 2\r\n    The aforementioned approach worked, however it was extremely slow and tedious.\r\n    The new approach changes the classnames of the DOM-elements directly, instead of\r\n    updating state (triggering re-render several times a second, which takes too much time).\r\n    This is bad practice, but for this purpose it works just fine, and is a lot quicker.\r\n    It also works easily because a node can only be in one of five states:\r\n    start, finish, visited, wall, or shortest-path. Therefore we can update them without issues.\r\n*/\r\n/* NOTE 3\r\n    Instead of referring directly to the DOM-element, one could instead use ReactRef.\r\n    However, that would imply that all of these functions would need to be implemented\r\n    in PathfinderVisualizer.js instead of this file, all inside the main React-component.\r\n    It would be better from a practice point-of-view, but would make the main file more\r\n    cluttered. Since this is a low scale project, referring directly to the DOM works fine,\r\n    so we will keep it like this for now.\r\n*/\r\nfunction animateAlgorithm(visitedNodesInOrder, shortestPath) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        if (i === visitedNodesInOrder.length) {\r\n            setTimeout(() => {\r\n                animateShortestPath(shortestPath);\r\n            }, 15 * i);\r\n            return;\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                if (!node.isStart && !node.isFinish) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                }\r\n            }, 15 * i);\r\n        }\r\n    }\r\n}\r\n\r\nfunction animateShortestPath(shortestPath) {\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n        setTimeout(() => {\r\n            const node = shortestPath[i];\r\n            if (!node.isFinish) {\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\r\n            }\r\n        }, 50 * i)\r\n    }\r\n}\r\n\r\nexport {\r\n    visualizeAlgorithm,\r\n};","import { getNeighbours } from \"./commonAlgorithmFunctions\";\r\n\r\n\r\nexport const aStar = function (grid, startNode, finishNode) {\r\n    const openList = [startNode];\r\n    const visitedNodesInOrder = [];\r\n    const closedList = [];\r\n\r\n    while (openList?.length) {\r\n        // Get node with least f since openList is always sorted on f\r\n        const currentNode = openList.shift();\r\n        // Push nodes for visualizing\r\n        visitedNodesInOrder.push(currentNode);\r\n        closedList.push(currentNode);\r\n\r\n        // If one is true, then both are. Redundant, but just to be sure\r\n        if (currentNode === finishNode || currentNode.isFinish) {\r\n            return visitedNodesInOrder;\r\n        }\r\n\r\n        // Generate neighbours\r\n        const currentNeighbours = getNeighbours(grid, currentNode);\r\n        for (const neighbour of currentNeighbours) {\r\n            \r\n            // If neighbour is a wall, or neighbour is in closedList, then skip it\r\n            if (neighbour.isWall || closedList.includes(neighbour)) continue;\r\n\r\n            // neighbour.g = current.g + neighbour.g\r\n            neighbour.distance = currentNode.distance + neighbour.cost;\r\n            // neighbour.f = neighbour.g + neighbour.h\r\n            neighbour.total = neighbour.distance + neighbour.manDistance;\r\n            // Find a node (if one exists) in the openList with same coordinates as neighbour\r\n            const currentNodeInOpenList = openList.find(node => {\r\n                return ((node.col === neighbour.col && node.row === neighbour.row) || node === neighbour);\r\n            });\r\n            // If the distance of the node in openList is less than neighbour's, then skip neighbour\r\n            if (currentNodeInOpenList?.distance <= neighbour.distance) {\r\n                continue;\r\n            }\r\n\r\n            // If none of the above are true, then add neighbour to openList\r\n            openList.push(neighbour);\r\n            neighbour.predecessor = currentNode;\r\n        }\r\n        //debugger;\r\n        // Sort based on total = f(n) = g(n) + h(n)\r\n        openList.sort((n1, n2) => n1.total - n2.total);\r\n    }\r\n    // If we end up here, then the goal is unreachable. Therefore return visited nodes\r\n    return visitedNodesInOrder;\r\n}","import React, {Component} from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { visualizeAlgorithm } from \"../algorithms/visualizingFunctions\";\r\n//import { act } from \"react-dom/test-utils\";\r\n\r\nconst text = `\r\n    Hello! And welcome to my Pathfinding-visualizer app!\\n\r\n    This app visualizes algorithms that find shortest paths between two points.\\n\r\n    You can choose between A* or Dijkstra (currently, but more will be implemented).\r\n    You can press the squares on your screen to make walls that cannot be passed through.\r\n    You can also hold down your mouse and drag it across the screen to make several in one go!\r\n    If you want to visualize how the algorithm finds the shortest path, simply click visualize! :)\r\n    You can also drag around the finish and start squares to change where the algorithm starts\r\n    and where it finishes.\r\n    You can reset the grid by pressing the reset-button, or generate a random maze (just random\r\n    walls) by pressing the generate-button. Have fun!\r\n    \\n\\n\r\n    Source code can be found at https://github.com/mathipe98\r\n    `;\r\n\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n    \r\n    constructor(props) {\r\n        super(props);\r\n        const stateVariable = {\r\n            currentAlgorithm: 'Dijkstra',\r\n            grid: [],\r\n            mousePressed: false,\r\n            animationIsActive: false,\r\n            canChangeGrid: true,\r\n            grabbedStart: false,\r\n            grabbedFinish: false,\r\n            START_ROW: 0,\r\n            START_COL: 0,\r\n            FINISH_ROW: 9,\r\n            FINISH_COL: 29,\r\n        }\r\n        this.state = stateVariable;\r\n        // Use ReactRef to refer to infoSheet, and consequently remove it\r\n        this.infoSheetRef = React.createRef();\r\n        this.removeInfoSheet = this.removeInfoSheet.bind(this);\r\n    }\r\n\r\n    /*\r\n    Function that will be called after render(). If no key is sent in the props of\r\n    the component, this function will only run once.\r\n    */\r\n    componentDidMount() {\r\n        const {START_ROW, START_COL, FINISH_ROW, FINISH_COL} = this.state;\r\n        const grid = createGrid(START_ROW, START_COL, FINISH_ROW, FINISH_COL);\r\n        //State of the grid will be the list of nodes in the grid\r\n        this.setState({grid});\r\n    }\r\n\r\n    // Function called when a button is clicked to visualize the result of\r\n    // the pathfinding algorithm. Performed by calling to other helper-functions\r\n    visualizeAlgorithm() {\r\n        // Can't visualize anything if previous visualization hasn't been reset\r\n        if (!this.state.canChangeGrid) return;\r\n        const {grid, currentAlgorithm, START_ROW, START_COL, FINISH_ROW, FINISH_COL} = this.state;\r\n        debugger;\r\n        // Outsourced visualizing to clean up this file\r\n        const timerLists = visualizeAlgorithm(grid, currentAlgorithm, START_ROW, START_COL, FINISH_ROW, FINISH_COL);\r\n        this.lockInterfaceInAnimation(timerLists[0], timerLists[1]); //visitedNodesInOrder, shortestPath\r\n    }\r\n\r\n    // Reset all walls/visited nodes\r\n    reset() {\r\n        // Cannot reset if animation is active\r\n        if (this.state.animationIsActive) return;\r\n        const resetGrid = createGrid(0, 0, 9, 29);\r\n        // Allow the change of the grid again\r\n        this.setState({canChangeGrid: true, grid: resetGrid, START_ROW: 0, START_COL: 0, FINISH_ROW: 9, FINISH_COL: 29});\r\n\r\n        // Because of changing classnames of DOM-elements, we have to reset their names\r\n        const actualGrid = this.state.grid;\r\n        for (let i = 0; i < actualGrid.length; i++) {\r\n            for (let j = 0; j < actualGrid[i].length; j++) {\r\n                const currentNode = actualGrid[i][j];\r\n                // Reset all nodes except start and finish\r\n                if (!currentNode.isStart && !currentNode.isFinish) {\r\n                    document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className = 'node';\r\n                }\r\n                else {\r\n                    console.log(`Start or finish coords: ${currentNode.row}, ${currentNode.col}`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Called when mouse is pressed down\r\n    onMouseDown(row, col) {\r\n        // Cannot change layout of grid if animation is active or reset has not been pushed\r\n        if (this.state.animationIsActive || !this.state.canChangeGrid) {\r\n            return;\r\n        }\r\n        // If current node is start, update state so that we know we are moving start-node\r\n        if (this.state.grid[row][col].isStart) {\r\n            this.setState({grabbedStart: true, mousePressed: true});\r\n            return;\r\n        }\r\n        // Likewise for finish-node\r\n        if (this.state.grid[row][col].isFinish) {\r\n            this.setState({grabbedFinish: true, mousePressed: true});\r\n            return;\r\n        }\r\n        // If we get here, then the entered node becomes a wall\r\n        const newGrid = getGridWithWalls(this.state.grid, row, col);\r\n        this.setState({grid: newGrid, mousePressed: true});\r\n    }\r\n\r\n    // Called when cursor enters a node\r\n    onMouseEnter(row, col) {\r\n        if (!this.state.mousePressed) return;\r\n        if (this.state.grabbedStart) {\r\n            this.changeStartOrFinishNode(row, col, true);\r\n            return;\r\n        }\r\n        if (this.state.grabbedFinish) {\r\n            this.changeStartOrFinishNode(row, col, false);\r\n            return;\r\n        }\r\n        const newGrid = getGridWithWalls(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n    }\r\n\r\n    // Called when letting go of the mouse button\r\n    onMouseUp() {\r\n        if (this.state.animationIsActive || !this.state.canChangeGrid) return;\r\n        const {grid, FINISH_ROW, FINISH_COL} = this.state;\r\n        console.log(FINISH_ROW, FINISH_COL);\r\n        const adjustedGrid = recalculateManDistance(grid, FINISH_ROW, FINISH_COL);\r\n        this.setState({grid: adjustedGrid, mousePressed: false, grabbedFinish: false, grabbedStart: false});\r\n    }\r\n\r\n    // When dragging the start node, iterate through the grid and update accordingly\r\n    // changeStart = true => change start-node, else change finish-node\r\n    changeStartOrFinishNode(row, col, changeStart) {\r\n        // Create a copy and setState because it will update with each change, and\r\n        // not just update when letting go (which happens if you directly modify state.grid)\r\n        const copyGrid = this.state.grid.slice();\r\n        for (let i = 0; i < copyGrid.length; i++) {\r\n            for (let j = 0; j < copyGrid[i].length; j++) {\r\n                const node = copyGrid[i][j];\r\n\r\n                // Change the start-node\r\n                if (changeStart) {\r\n                    if (node.isStart) {\r\n                        // Remember to set distance to infinity when node isn't start\r\n                        copyGrid[i][j] = {\r\n                            ...node,\r\n                            isStart: !node.isStart,\r\n                            distance: Infinity,\r\n                        };\r\n                    }\r\n                    // If this is true, then this is the current node which we want to change to\r\n                    if (row === i & col === j) {\r\n                        // Likewise, set distance to 0 when node is start\r\n                        copyGrid[i][j] = {\r\n                            ...node,\r\n                            isStart: true,\r\n                            distance: 0,\r\n                        };\r\n                    }\r\n                }\r\n\r\n                // Change finish node\r\n                else {\r\n                    if (node.isFinish) {\r\n                        copyGrid[i][j] = {\r\n                            ...node,\r\n                            isFinish: !node.isFinish,\r\n                        };\r\n                    }\r\n                    if (row === i & col === j) {\r\n                        copyGrid[i][j] = {\r\n                            ...node,\r\n                            isFinish: true,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Set state to update with each change\r\n        if (changeStart) {\r\n            this.setState({grid: copyGrid, START_ROW: row, START_COL: col});\r\n        }\r\n        else {\r\n            this.setState({grid: copyGrid, FINISH_ROW: row, FINISH_COL: col});\r\n        }\r\n    }\r\n    \r\n\r\n    // Set state-variable to know which algorithm to visualize\r\n    setAlgorithmOnClick(algorithm) {\r\n        if (this.state.animationIsActive || !this.state.canChangeGrid) return;\r\n        // Highlight the algorithm that is chosen such that it remains highlighted post-click\r\n        highlightButtons(algorithm);\r\n        this.setState({currentAlgorithm: algorithm});\r\n    }\r\n\r\n    // Function that makes sure that we cannot alter the grid when animation is ongoing\r\n    lockInterfaceInAnimation(visitedNodesInOrder, shortestPath) {\r\n        // animationIsActive makes sure we cannot change the grid layout mid-animation\r\n        // canChangeGrid makes sure we cannot change grid post-animation; we have to press\r\n        // the reset button in order to be able to change the grid again.\r\n        this.setState({animationIsActive: true, canChangeGrid: false});\r\n        setTimeout(() => {\r\n            this.setState({animationIsActive: false});\r\n        }, 15 * (visitedNodesInOrder.length + 1) + 50 * (shortestPath.length + 1) + 1000);\r\n    }\r\n\r\n    // Iterates through all nodes in the grid and generates a random number\r\n    // that decides whether or not a node is a wall\r\n    // Note: it does not take into account if a node already is a wall, so if\r\n    // called several times, more nodes will become walls\r\n    generateRandomMaze(grid) {\r\n        // If we are done with the animation, then we cannot create a random maze\r\n        if (!this.state.canChangeGrid) return;\r\n        // Calculate random row/col values to set a random start/finish at the end of the function\r\n        const randomNumbers = getRandomStartFinish(grid);\r\n        const randomRow1 = randomNumbers[0];\r\n        const randomRow2 = randomNumbers[1];\r\n        const randomCol1 = randomNumbers[2];\r\n        const randomCol2 = randomNumbers[3];\r\n\r\n        //Create a new grid instead of altering the current one\r\n        const cleanGrid = createGrid(randomRow1, randomCol1, randomRow2, randomCol2);\r\n        for (let i = 0; i < cleanGrid.length; i++) {\r\n            for (let j = 0; j < cleanGrid[i].length; j++) {\r\n                const node = cleanGrid[i][j];\r\n\r\n                if (node.isStart || node.isFinish) continue;\r\n                // Random number between 0 and 9\r\n                const randomNumber = Math.floor(Math.random() * 10);\r\n                // The higher the number on the right, the more walls generated\r\n                // 3 seemed like a fair balance; 30% of nodes will be walls\r\n                if (randomNumber < 3) {\r\n                    node.isWall = true;\r\n                }\r\n            }\r\n        }\r\n        this.setState({grid: cleanGrid, START_ROW: randomRow1, START_COL: randomCol1, FINISH_ROW: randomRow2, FINISH_COL: randomCol2});\r\n    }\r\n\r\n    // Remove the text-box that informs the user of the app-functionality\r\n    removeInfoSheet() {\r\n        this.infoSheetRef.current.remove();\r\n    }\r\n\r\n\r\n    render() {\r\n        //Extract list of nodes currently in the grid\r\n        const {grid, mousePressed} = this.state;\r\n        /*\r\n        Inside the return function, we will iterate through all rows, and for each row\r\n        we will create a <Node></Node> object for each column.\r\n        This will in essence translate to making a single box for each item in \r\n        the nodes-array. Keep note of indexes to assess position of each node\r\n        */\r\n        return (\r\n            <>\r\n                <div className=\"infoSheet\" ref={this.infoSheetRef} onMouseUp={() => this.onMouseUp()}>\r\n                    <div className=\"boxclose\" onClick={() => this.removeInfoSheet()}></div>\r\n                    {text}\r\n                </div>\r\n                <div id={\"menu\"} onMouseUp={() => this.onMouseUp()}>\r\n                    <button className=\"menuButton\" onClick={() => this.visualizeAlgorithm()}>\r\n                        Visualize\r\n                    </button>\r\n                    <button className=\"menuButton\" onClick={() => this.reset()}>\r\n                        Reset\r\n                    </button>\r\n                    <button className=\"algoButton active\" id=\"Dijkstra\" onClick={() => this.setAlgorithmOnClick(\"Dijkstra\")}>\r\n                        Dijkstra's\r\n                    </button>\r\n                    <button className=\"algoButton\" id=\"Astar\" onClick={() => this.setAlgorithmOnClick(\"Astar\")} >\r\n                        A*\r\n                    </button>\r\n                    <button className=\"menuButton\" onClick={() => this.generateRandomMaze(grid)}>\r\n                        Generate random maze\r\n                    </button>\r\n                </div>\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIndex) => {\r\n                        return (\r\n                        <div key={rowIndex} className=\"row\">\r\n                            {row.map((node, nodeIndex) => {\r\n                                //extract attributes from node-object in map-function\r\n                                const {\r\n                                    row,\r\n                                    col,\r\n                                    isStart,\r\n                                    isFinish,\r\n                                    isVisited,\r\n                                    isWall,\r\n                                } = node;\r\n                                return (\r\n                                    <Node\r\n                                    key={nodeIndex}\r\n                                    row={row}\r\n                                    col={col}\r\n                                    isStart={isStart}\r\n                                    isFinish={isFinish}\r\n                                    isVisited={isVisited}\r\n                                    isWall={isWall}\r\n                                    mousePressed={mousePressed}\r\n                                    onMouseDown={(row, col) => this.onMouseDown(row, col)}\r\n                                    onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\r\n                                    onMouseUp={() => this.onMouseUp()}></Node>\r\n                                    );\r\n                            })}\r\n                        </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n// Calculates rows and columns in grid according to screen size\r\nconst rowsAndCols = calculateRowsAndCols();\r\nconst rows = rowsAndCols[0];\r\nconst cols = rowsAndCols[1];\r\n\r\n//Helper function for creating an array of arrays with nodes\r\nfunction createGrid(START_ROW, START_COL, FINISH_ROW, FINISH_COL) {\r\n    const grid = [];\r\n    for (let i = 0; i < rows; i++) {\r\n        const currentRow = [];\r\n        for (let j = 0; j < cols; j++) {\r\n            const currentNode = createNode(i, j, START_ROW, START_COL, FINISH_ROW, FINISH_COL);\r\n            currentRow.push(currentNode);\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\n//Helper function for creating a node with attributes for usage in pathfinding-algorithms\r\nfunction createNode(row, col, START_ROW, START_COL, FINISH_ROW, FINISH_COL) {\r\n    const isStart = (row === START_ROW && col === START_COL);\r\n    const isFinish = (row === FINISH_ROW && col === FINISH_COL);\r\n    // Manhattan distance for use in A*\r\n    const manDistance = Math.abs(row - FINISH_ROW) + Math.abs(col - FINISH_COL);\r\n    const currentNode = {\r\n        row,\r\n        col,\r\n        isStart,\r\n        isFinish,\r\n        isVisited: false,\r\n        isWall: false,\r\n        distance: isStart ? 0 : Infinity,\r\n        cost: 1,\r\n        manDistance,\r\n        total: isStart ? 0 : Infinity,\r\n        predecessor: null,\r\n    };\r\n    return currentNode;\r\n}\r\n\r\n//Create a copy grid with the node passed in as a wall\r\nfunction getGridWithWalls(grid, row, col) {\r\n    const copyGrid = grid.slice();\r\n    const node = copyGrid[row][col];\r\n    copyGrid[row][col] = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    return copyGrid;\r\n}\r\n\r\nfunction recalculateManDistance(grid, FINISH_ROW, FINISH_COL) {\r\n    const resultGrid = grid.slice();\r\n    for (let i = 0; i < resultGrid.length; i++) {\r\n        for (let j = 0; j < resultGrid[i].length; j++) {\r\n            const node = resultGrid[i][j];\r\n            const distance = Math.abs(i - FINISH_ROW) + Math.abs(j - FINISH_COL);\r\n            resultGrid[i][j] = {\r\n                ...node,\r\n                manDistance: distance,\r\n            };\r\n        }\r\n    }\r\n    return resultGrid;\r\n}\r\n\r\n// Calculates how many nodes will appear according to screen size\r\nfunction calculateRowsAndCols() {\r\n    const screen = document.getElementById(\"body\");\r\n    const screenWidth = screen.offsetWidth;\r\n    const screenHeight = screen.offsetHeight;\r\n    if (screenWidth <= 1280 && screenHeight <= 590) {\r\n        // Reduce height by 144px since this is the height of the menu\r\n        // gridHeight = bodyHeight - menuHeight. Ref: PathfindingVisualizer.css\r\n        return [Math.floor((screenHeight - 144) / 24), Math.floor(screenWidth / 24)];\r\n    }\r\n    else if (screenWidth <= 1920 && screenHeight <= 940) {\r\n        // menuHeight = 217px\r\n        return [Math.floor((screenHeight - 217) / 24), Math.floor(screenWidth / 24)];\r\n        //return [30, 76];\r\n    }\r\n    else { //Assume max screen size and resolution is 2560x1440 and size = 27\"\r\n        // menuHeight = 241px\r\n        return [Math.floor((screenHeight - 241) / 24), Math.floor(screenWidth / 24)];\r\n    }\r\n}\r\n\r\nfunction getRandomValues(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nfunction getRandomStartFinish(grid) {\r\n    // Calculate random row/col values to set a random start/finish at the end of the function\r\n    let randomRow1 = getRandomValues(0, grid.length - 1);\r\n    let randomRow2 = getRandomValues(0, grid.length - 1);\r\n    let randomCol1 = getRandomValues(0, grid[0].length - 1);\r\n    let randomCol2 = getRandomValues(0, grid[0].length - 1);\r\n    // If they are the exact same, which is extremely unlikely, but nonetheless possible\r\n    if (randomRow1 === randomRow2 && randomCol1 === randomCol2) {\r\n        let ok = false;\r\n        while (!ok) {\r\n            randomRow1 = getRandomValues(0, grid.length - 1);\r\n            randomRow2 = getRandomValues(0, grid.length - 1);\r\n            randomCol1 = getRandomValues(0, grid[0].length - 1);\r\n            randomCol2 = getRandomValues(0, grid[0].length - 1);\r\n            if (randomRow1 !== randomRow2 || randomCol1 !== randomCol2) {\r\n                ok = true;\r\n            }\r\n        }\r\n    }\r\n    console.log(`Max row: ${grid.length}. Max col: ${grid[0].length}`);\r\n    console.log(`Random rows: ${randomRow1}, ${randomRow2}. Random cols: ${randomCol1}, ${randomCol2}`);\r\n    return [randomRow1, randomRow2, randomCol1, randomCol2];\r\n}\r\n\r\n// Directly access the DOM-elements with id/className instead of adding\r\n// eventListener-functions because those functions cannot take into account\r\n// that the animation is ongoing or that the grid hasn't reset\r\nfunction highlightButtons(id) {\r\n    const activeButton = document.getElementsByClassName(\"active\")[0];\r\n    activeButton.className = activeButton.className.replace(\" active\", \"\");\r\n    document.getElementById(id).className += \" active\";\r\n}\r\n\r\n/*\r\nfor (var i = 0; i < btns.length; i++) {\r\n        btns[i].addEventListener(\"click\", function() {\r\n            var current = document.getElementsByClassName(\"active\");\r\n            current[0].className = current[0].className.replace(\" active\", \"\");\r\n            this.className += \" active\";\r\n        });\r\n    }\r\n*/","import React from \"react\";\r\nimport Pathfind from \"./components/PathfindingVisualizer\"\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Pathfind></Pathfind>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}