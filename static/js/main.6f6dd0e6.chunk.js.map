{"version":3,"sources":["components/Node/Node.js","algorithms/commonAlgorithmFunctions.js","algorithms/dijkstra.js","algorithms/visualizingFunctions.js","algorithms/A_star.js","components/PathfindingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isFinish","isWall","isVisited","onMouseDown","onMouseEnter","onMouseUp","extraNameCheck","id","className","Component","getNeighbours","grid","node","maxRowIndex","length","maxColIndex","topNeighbour","bottomNeighbour","filter","checkNode","sort","n1","n2","distance","relax","currentNode","neighbour","tempDistance","cost","predecessor","visualizeAlgorithm","currentAlgorithm","START_ROW","START_COL","FINISH_ROW","FINISH_COL","startNode","finishNode","visitedNodesInOrder","queue","nodeList","i","j","push","getAllNodes","shift","Infinity","currentNeighbours","dijkstraSearch","openList","closedList","console","log","includes","total","manDistance","currentNodeInOpenList","find","aStar","shortestPath","result","backtrackShortestPath","setTimeout","document","getElementById","animateShortestPath","animateAlgorithm","rowsAndCols","screen","screenWidth","offsetWidth","screenHeight","offsetHeight","Math","floor","calculateRowsAndCols","rows","cols","PathfindingVisualizer","mousePressed","animationIsActive","canChangeGrid","createGrid","setState","timerLists","lockInterfaceInAnimation","actualGrid","resetGrid","newGrid","getGridWithWalls","algorithm","activeButton","getElementsByClassName","replace","highlightButtons","copyGrid","slice","random","onClick","reset","setAlgorithmOnClick","generateRandomMaze","map","rowIndex","nodeIndex","currentRow","createNode","abs","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6f6dd0e6.chunk.js","sourcesContent":["import React,  {Component} from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        //The same way as in PathfindingVisualizer, extract values from props\r\n        const {\r\n            row,\r\n            col,\r\n            isStart,\r\n            isFinish,\r\n            isWall,\r\n            isVisited,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n        } = this.props;\r\n\r\n        const extraNameCheck = isStart\r\n            ? \"node-start\"\r\n            : isFinish\r\n            ? \"node-finish\"\r\n            : isWall\r\n            ? \"node-wall\"\r\n            : isVisited\r\n            ? \"node-visited\"\r\n            : \"\";\r\n        /*\r\n            We pass functions into the props for handling mouse-events,\r\n            and add these event-listener functions to the Node-component.\r\n            Each individual node will simply have a function to handle\r\n            a mouseDown, mouseEnter, or mouseUp event, such that all of them\r\n            can use their individual row-col values.\r\n        */\r\n        return (\r\n            <div\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraNameCheck}`}\r\n            isWall={isWall}\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseUp={() => onMouseUp()}\r\n            ></div>\r\n        );\r\n    }\r\n}\r\n/*\r\nconstructor(props) {\r\n        super(props);\r\n        this.state = [];\r\n    }\r\n*/","\r\nfunction getNeighbours(grid, node) {\r\n    const {row, col} = node;\r\n    const maxRowIndex = grid.length - 1;\r\n    const maxColIndex = grid[0].length - 1;\r\n\r\n    const topNeighbour = (row > 0) ? grid[row-1][col] : null;\r\n    const bottomNeighbour = (row < maxRowIndex) ? grid[row+1][col] : null;\r\n    const rightNeighbour = (col < maxColIndex) ? grid[row][col+1] : null;\r\n    const leftNeighbour = (col > 0) ? grid[row][col-1] : null;\r\n    const neighbourList = [topNeighbour, rightNeighbour, bottomNeighbour, leftNeighbour];\r\n\r\n    // Filter out null-nodes, visited nodes, wall nodes, and sort the list\r\n    // where nodes with minimal distance will appear first\r\n    const result = neighbourList\r\n        .filter(checkNode)\r\n        .sort((n1, n2) => n1.distance - n2.distance);\r\n    return result;\r\n}\r\n\r\n// Check if a node is null, visited, or a wall\r\nfunction checkNode(node) {\r\n    if (node === null) {\r\n        return false;\r\n    }\r\n    if (node.isVisited) {\r\n        return false;\r\n    }\r\n    if (node.isWall) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n// Backtrack the shortest path. Must be called after dijkstraSearch\r\nfunction backtrackShortestPath (finishNode) {\r\n    const result = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode.predecessor) {\r\n        result.push(currentNode);\r\n        currentNode = currentNode.predecessor;\r\n    }\r\n    return result;\r\n}\r\n\r\n\r\n\r\nexport {\r\n    getNeighbours,\r\n    checkNode,\r\n    backtrackShortestPath,\r\n};","\r\nimport { getNeighbours } from \"./commonAlgorithmFunctions\";\r\n\r\n/*\r\nThe main idea in these algorithms will be to first implement the functions that\r\nprovide the actual solution, and then implement functions that will visualize\r\nthese solutions by altering the classname of each explored node in order to\r\ncolorize which nodes are in progress, which ones are visited, and ultimately \r\nhighlight the final path. The animation will be taken care of in\r\nPathfindingVisualizer, while we provide the actual backend of the algorithms here.\r\n*/\r\n\r\n// Dijkstra's algorithm: takes in a grid of nodes, along with start and finish,\r\n// and checks two nodes u,v if it's cheaper/more efficient to move\r\n// from node u to v instead of the path v already has.\r\n// Also updates each node with a pointer to its predecessor.\r\nfunction dijkstraSearch(grid, startNode, finishNode) {\r\n\r\n    const queue = getAllNodes(grid);\r\n    const visitedNodesInOrder = [];\r\n    \r\n    // equivalent to (queue && queue.length)\r\n    while (queue?.length) {\r\n        //debugger;\r\n\r\n        \r\n        // Because of the sorting, this node is guaranteed to have the lowest distance\r\n        const currentNode = queue.shift();\r\n\r\n        // If a wall is encountered, skip the node\r\n        if (currentNode.isWall) continue;\r\n\r\n        \r\n        // If we end up here, then we are trapped, and therefore return the list of nodes\r\n        if (currentNode.distance === Infinity) {\r\n            return visitedNodesInOrder;\r\n        }\r\n        // Break if we have found the target (might delete later to calculate all-to-all)\r\n        if (currentNode === finishNode) {\r\n            return visitedNodesInOrder;\r\n        }\r\n        \r\n        // Get all neighbours of current node\r\n        const currentNeighbours = getNeighbours(grid, currentNode);\r\n        visitedNodesInOrder.push(currentNode);\r\n        // Iterate through neighbours and relax the edges\r\n        for (let neighbour of currentNeighbours) {\r\n            relax(currentNode, neighbour);\r\n        }\r\n        queue.sort((n1, n2) => n1.distance - n2.distance);\r\n    }\r\n}\r\n\r\n// Relax an edge between u and v:\r\n// if (u.distance + cost(go from u to v) < v.distance)\r\n// => v.distance = u.distance cost(go from u to v);\r\n// => v.predecessor = u;\r\nfunction relax(currentNode, neighbour) {\r\n    const tempDistance = currentNode.distance + neighbour.cost;\r\n        if (tempDistance < neighbour.distance) {\r\n            neighbour.distance = tempDistance;\r\n            neighbour.predecessor = currentNode;\r\n        }\r\n}\r\n\r\n// Returns a sorted list of all nodes in the grid where the sorting\r\n// is based on the distance of each node\r\nfunction getAllNodes(grid) {\r\n    const nodeList = [];\r\n    for (let i = 0; i < grid.length; i++) {\r\n        const row = grid[i];\r\n        for (let j = 0; j < row.length; j++) {\r\n            nodeList.push(row[j]);\r\n        }\r\n    }\r\n    const result = nodeList.sort((n1, n2) => n1.distance - n2.distance);\r\n    return result;\r\n}\r\n\r\nexport {dijkstraSearch, relax, getAllNodes};","import {dijkstraSearch} from \"./dijkstra.js\";\r\nimport {aStar} from \"./A_star\";\r\nimport { backtrackShortestPath } from \"./commonAlgorithmFunctions\";\r\n\r\n// Function called when a button is clicked to visualize the result of\r\n// the pathfinding algorithm. Performed by calling to other helper-functions\r\nfunction visualizeAlgorithm(grid, currentAlgorithm, START_ROW, START_COL, FINISH_ROW, FINISH_COL) {\r\n    const startNode = grid[START_ROW][START_COL];\r\n    const finishNode = grid[FINISH_ROW][FINISH_COL];\r\n\r\n    const visitedNodesInOrder = (currentAlgorithm === \"Dijkstra\") ?\r\n        dijkstraSearch(grid, startNode, finishNode) : (currentAlgorithm === \"Astar\") ?\r\n        aStar(grid, startNode, finishNode) : null; // can add more later\r\n\r\n    const shortestPath = backtrackShortestPath(finishNode);\r\n    animateAlgorithm(visitedNodesInOrder, shortestPath);\r\n    // Return the lists in case we need to use them, thus we don't have to recalculate them\r\n    return [visitedNodesInOrder, shortestPath];\r\n}\r\n\r\n/* NOTE 1\r\n    The way we animate the pathfinder-algorithm, is to have\r\n    an array of visited nodes, and create a copy of the existing\r\n    grid every time we iterate through a visited node.\r\n    This is as an external function that sets a timeout every time\r\n    a node is iterated, instead of being taken care of inside of\r\n    the render function. We iterate through all visited nodes, and\r\n    for each node, we create a copy grid, and a copy node.\r\n    We replace the existing node in the copy grid, with the\r\n    copy node that has updated its isVisited-state.\r\n    We pass in the copy grid as the new state of the React-component,\r\n    and set a timeout. Therefore, the state will update itself with\r\n    an interval of the timeout-value, which will be perceived as\r\n    individual boxes changing their layouts because every state-update\r\n    changes a single node. \r\n*/\r\n/* NOTE 2\r\n    The aforementioned approach worked, however it was extremely slow and tedious.\r\n    The new approach changes the classnames of the DOM-elements directly, instead of\r\n    updating state (triggering re-render several times a second, which takes too much time).\r\n    This is bad practice, but for this purpose it works just fine, and is a lot quicker.\r\n    It also works easily because a node can only be in one of five states:\r\n    start, finish, visited, wall, or shortest-path. Therefore we can update them without issues.\r\n*/\r\nfunction animateAlgorithm(visitedNodesInOrder, shortestPath) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        if (i === visitedNodesInOrder.length) {\r\n            setTimeout(() => {\r\n                animateShortestPath(shortestPath);\r\n            }, 15 * i);\r\n            return;\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                if (!node.isStart && !node.isFinish) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\r\n                }\r\n            }, 15 * i);\r\n        }\r\n    }\r\n}\r\n\r\nfunction animateShortestPath(shortestPath) {\r\n    for (let i = 0; i < shortestPath.length; i++) {\r\n        setTimeout(() => {\r\n            const node = shortestPath[i];\r\n            if (!node.isFinish) {\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\r\n            }\r\n        }, 50 * i)\r\n    }\r\n}\r\n\r\nexport {\r\n    visualizeAlgorithm,\r\n};","import { getNeighbours } from \"./commonAlgorithmFunctions\";\r\n\r\n\r\nexport const aStar = function (grid, startNode, finishNode) {\r\n    const openList = [startNode];\r\n    const visitedNodesInOrder = [];\r\n    const closedList = [];\r\n\r\n    while (openList?.length) {\r\n        // Get node with least f since openList is always sorted on f\r\n        const currentNode = openList.shift();\r\n        // Push nodes for visualizing\r\n        visitedNodesInOrder.push(currentNode);\r\n        console.log(currentNode);\r\n        closedList.push(currentNode);\r\n\r\n        // If one is true, then both are. Redundant, but just to be sure\r\n        if (currentNode === finishNode || currentNode.isFinish) {\r\n            return visitedNodesInOrder;\r\n        }\r\n\r\n        // Generate neighbours\r\n        const currentNeighbours = getNeighbours(grid, currentNode);\r\n        for (const neighbour of currentNeighbours) {\r\n            \r\n            // If neighbour is a wall, or neighbour is in closedList, then skip it\r\n            if (neighbour.isWall || closedList.includes(neighbour)) continue;\r\n\r\n            // neighbour.g = current.g + neighbour.g\r\n            neighbour.distance = currentNode.distance + neighbour.cost;\r\n            // neighbour.f = neighbour.g + neighbour.h\r\n            neighbour.total = neighbour.distance + neighbour.manDistance;\r\n            // Find a node (if one exists) in the openList with same coordinates as neighbour\r\n            const currentNodeInOpenList = openList.find(node => {\r\n                return ((node.col === neighbour.col && node.row === neighbour.row) || node === neighbour);\r\n            });\r\n            // If the distance of the node in openList is less than neighbour's, then skip neighbour\r\n            if (currentNodeInOpenList?.distance <= neighbour.distance) {\r\n                continue;\r\n            }\r\n\r\n            // If none of the above are true, then add neighbour to openList\r\n            openList.push(neighbour);\r\n            neighbour.predecessor = currentNode;\r\n        }\r\n        //debugger;\r\n        // Sort based on total = f(n) = g(n) + h(n)\r\n        openList.sort((n1, n2) => n1.total - n2.total);\r\n    }\r\n    // If we end up here, then the goal is unreachable. Therefore return visited nodes\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n\r\n// Check if a node is null, visited, or a wall\r\nfunction checkNode(node) {\r\n    if (node === null) {\r\n        return false;\r\n    }\r\n    if (node.isWall) {\r\n        return false;\r\n    }\r\n    return true;\r\n}","import React, {Component} from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { visualizeAlgorithm } from \"../algorithms/visualizingFunctions\";\r\nimport { act } from \"react-dom/test-utils\";\r\n\r\nconst rowsAndCols = calculateRowsAndCols();\r\n//console.log(`Body width: ${body.offsetWidth}. Body height: ${body.offsetHeight}`);\r\nconsole.log(`Number of rows: ${rowsAndCols[0]}. Number of cols: ${rowsAndCols[1]}`);\r\nconst rows = rowsAndCols[0];\r\nconst cols = rowsAndCols[1];\r\n\r\nconst START_ROW = 0;\r\nconst START_COL = 0;\r\nconst FINISH_ROW = 9;\r\nconst FINISH_COL = 29;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            currentAlgorithm: 'Dijkstra',\r\n            grid: [],\r\n            mousePressed: false,\r\n            animationIsActive: false,\r\n            canChangeGrid: true,\r\n        };\r\n    }\r\n\r\n    /*\r\n    Function that will be called after render(). If no key is sent in the props of\r\n    the component, this function will only run once.\r\n    */\r\n    componentDidMount() {\r\n        const grid = createGrid();\r\n        //State of the grid will be the list of nodes in the grid\r\n        this.setState({grid});\r\n    }\r\n\r\n    // Function called when a button is clicked to visualize the result of\r\n    // the pathfinding algorithm. Performed by calling to other helper-functions\r\n    visualizeAlgorithm() {\r\n        console.log(this.state.canChangeGrid);\r\n        if (!this.state.canChangeGrid) return;\r\n        const {grid, currentAlgorithm} = this.state;\r\n        // Outsourced visualizing to clean up this file\r\n        const timerLists = visualizeAlgorithm(grid, currentAlgorithm, START_ROW, START_COL, FINISH_ROW, FINISH_COL);\r\n        this.lockInterfaceInAnimation(timerLists[0], timerLists[1]); //visitedNodesInOrder, shortestPath\r\n    }\r\n\r\n    // Reset all walls/visited nodes\r\n    reset() {\r\n        // Cannot reset if animation is active\r\n        if (this.state.animationIsActive) return;\r\n        // Allow the change of the grid again\r\n        this.setState({canChangeGrid: true});\r\n        // Because of changing classnames of DOM-elements, we have to reset their names\r\n        const actualGrid = this.state.grid;\r\n        for (let i = 0; i < actualGrid.length; i++) {\r\n            for (let j = 0; j < actualGrid[i].length; j++) {\r\n                const currentNode = actualGrid[i][j];\r\n                // Reset all nodes except start and finish\r\n                if (!currentNode.isStart && !currentNode.isFinish) {\r\n                    document.getElementById(`node-${currentNode.row}-${currentNode.col}`).className = 'node';\r\n                }\r\n            }\r\n        }\r\n\r\n        const resetGrid = createGrid();\r\n        this.setState({grid: resetGrid});\r\n    }\r\n\r\n    onMouseDown(row, col) {\r\n        // Cannot change layout of grid if animation is active or reset has not been pushed\r\n        if (this.state.animationIsActive || !this.state.canChangeGrid) {\r\n            return;\r\n        }\r\n        const newGrid = getGridWithWalls(this.state.grid, row, col);\r\n        this.setState({grid: newGrid, mousePressed: true});\r\n    }\r\n\r\n    onMouseEnter(row, col) {\r\n        if (!this.state.mousePressed) return;\r\n        const newGrid = getGridWithWalls(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n    }\r\n\r\n    onMouseUp() {\r\n        if (this.state.animationIsActive || !this.state.canChangeGrid) return;\r\n        this.setState({mousePressed: false});\r\n    }\r\n\r\n    // Set state-variable to know which algorithm to visualize\r\n    setAlgorithmOnClick(algorithm) {\r\n        console.log(`Animation active: ${this.state.animationIsActive}. Can change grid: ${this.state.canChangeGrid}`);\r\n        if (this.state.animationIsActive || !this.state.canChangeGrid) return;\r\n        else {\r\n            console.log(\"Why the hell are we getting here?\");\r\n            highlightButtons(algorithm);\r\n            this.setState({currentAlgorithm: algorithm});\r\n        }\r\n    }\r\n\r\n    lockInterfaceInAnimation(visitedNodesInOrder, shortestPath) {\r\n        // animationIsActive makes sure we cannot change the grid layout mid-animation\r\n        // canChangeGrid makes sure we cannot change grid post-animation; we have to press\r\n        // the reset button in order to be able to change the grid again.\r\n        this.setState({animationIsActive: true, canChangeGrid: false});\r\n        setTimeout(() => {\r\n            this.setState({animationIsActive: false});\r\n        }, 15 * (visitedNodesInOrder.length + 1) + 50 * (shortestPath.length + 1) + 1000);\r\n    }\r\n\r\n    generateRandomMaze(grid) {\r\n        if (!this.state.canChangeGrid) return;\r\n        const copyGrid = grid.slice();\r\n        for (let i = 0; i < copyGrid.length; i++) {\r\n            for (let j = 0; j < copyGrid[i].length; j++) {\r\n                const node = copyGrid[i][j];\r\n                if (node.isStart || node.isFinish) continue;\r\n                const randomNumber = Math.floor(Math.random() * 10);\r\n                if (randomNumber < 3) {\r\n                    copyGrid[i][j] = {\r\n                        ...node,\r\n                        isWall: !node.isWall,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        this.setState({grid: copyGrid});\r\n    }\r\n\r\n\r\n    render() {\r\n        //Extract list of nodes currently in the grid\r\n        const {grid, mousePressed} = this.state;\r\n        /*\r\n        Inside the return function, we will iterate through all rows, and for each row\r\n        we will create a <Node></Node> object for each column.\r\n        This will in essence translate to making a single box for each item in \r\n        the nodes-array. Keep note of indexes to assess position of each node\r\n        */\r\n        return (\r\n            <>\r\n                <div id={\"menu\"}>\r\n                    <button className=\"menuButton\" onClick={() => this.visualizeAlgorithm()}>\r\n                        Visualize\r\n                    </button>\r\n                    <button className=\"menuButton\" onClick={() => this.reset()}>\r\n                        Reset\r\n                    </button>\r\n                    <button className=\"algoButton active\" id=\"Dijkstra\" onClick={() => this.setAlgorithmOnClick(\"Dijkstra\")}>\r\n                        Dijkstra's\r\n                    </button>\r\n                    <button className=\"algoButton\" id=\"Astar\" onClick={() => this.setAlgorithmOnClick(\"Astar\")} >\r\n                        A*\r\n                    </button>\r\n                    <button className=\"menuButton\" onClick={() => this.generateRandomMaze(grid)}>\r\n                        Generate random maze\r\n                    </button>\r\n                </div>\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIndex) => {\r\n                        return (\r\n                        <div key={rowIndex} className=\"row\">\r\n                            {row.map((node, nodeIndex) => {\r\n                                //extract attributes from node-object in map-function\r\n                                const {\r\n                                    row,\r\n                                    col,\r\n                                    isStart,\r\n                                    isFinish,\r\n                                    isVisited,\r\n                                    isWall,\r\n                                } = node;\r\n                                return (\r\n                                    <Node\r\n                                    key={nodeIndex}\r\n                                    row={row}\r\n                                    col={col}\r\n                                    isStart={isStart}\r\n                                    isFinish={isFinish}\r\n                                    isVisited={isVisited}\r\n                                    isWall={isWall}\r\n                                    mousePressed={mousePressed}\r\n                                    onMouseDown={(row, col) => this.onMouseDown(row, col)}\r\n                                    onMouseEnter={(row, col) => this.onMouseEnter(row, col)}\r\n                                    onMouseUp={() => this.onMouseUp()}></Node>\r\n                                    );\r\n                            })}\r\n                        </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n\r\n//Helper function for creating an array of arrays with nodes\r\nfunction createGrid() {\r\n    const grid = [];\r\n    for (let i = 0; i < rows; i++) {\r\n        const currentRow = [];\r\n        for (let j = 0; j < cols; j++) {\r\n            const currentNode = createNode(i, j);\r\n            currentRow.push(currentNode);\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\n//Helper function for creating a node with attributes for usage in pathfinding-algorithms\r\nfunction createNode(row, col) {\r\n    const isStart = (row === START_ROW && col === START_COL);\r\n    const isFinish = (row === FINISH_ROW && col === FINISH_COL);\r\n    const manDistance = Math.abs(row - FINISH_ROW) + Math.abs(col - FINISH_COL);\r\n    const currentNode = {\r\n        row,\r\n        col,\r\n        isStart,\r\n        isFinish,\r\n        isVisited: false,\r\n        isWall: false,\r\n        distance: isStart ? 0 : Infinity,\r\n        cost: 1,\r\n        manDistance,\r\n        total: isStart ? 0 : Infinity,\r\n        predecessor: null,\r\n    };\r\n    return currentNode;\r\n}\r\n\r\nfunction getGridWithWalls(grid, row, col) {\r\n    const copyGrid = grid.slice();\r\n    const node = copyGrid[row][col];\r\n    copyGrid[row][col] = {\r\n        ...node,\r\n        isWall: !node.isWall,\r\n    };\r\n    return copyGrid;\r\n}\r\n\r\n// Calculates how many nodes will appear according to screen size\r\nfunction calculateRowsAndCols() {\r\n    const screen = document.getElementById(\"body\");\r\n    const screenWidth = screen.offsetWidth;\r\n    const screenHeight = screen.offsetHeight;\r\n    if (screenWidth <= 1280 && screenHeight <= 590) {\r\n        // Reduce height by 144px since this is the height of the menu\r\n        // gridHeight = bodyHeight - menuHeight. Ref: PathfindingVisualizer.css\r\n        return [Math.floor((screenHeight - 144) / 24), Math.floor(screenWidth / 24)];\r\n    }\r\n    else if (screenWidth <= 1920 && screenHeight <= 940) {\r\n        // menuHeight = 217px\r\n        return [Math.floor((screenHeight - 217) / 24), Math.floor(screenWidth / 24)];\r\n        //return [30, 76];\r\n    }\r\n    else { //Assume max screen size and resolution is 2560x1440 and size = 27\"\r\n        // menuHeight = 241px\r\n        return [Math.floor((screenHeight - 241) / 24), Math.floor(screenWidth / 24)];\r\n    }\r\n}\r\n\r\n// Directly access the DOM-elements with id/className instead of adding\r\n// eventListener-functions because those functions cannot take into account\r\n// that the animation is ongoing or that the grid hasn't reset\r\nfunction highlightButtons(id) {\r\n    const activeButton = document.getElementsByClassName(\"active\")[0];\r\n    activeButton.className = activeButton.className.replace(\" active\", \"\");\r\n    document.getElementById(id).className += \" active\";\r\n}\r\n\r\n/*\r\nfor (var i = 0; i < btns.length; i++) {\r\n        btns[i].addEventListener(\"click\", function() {\r\n            var current = document.getElementsByClassName(\"active\");\r\n            current[0].className = current[0].className.replace(\" active\", \"\");\r\n            this.className += \" active\";\r\n        });\r\n    }\r\n*/","import React from \"react\";\r\nimport Pathfind from \"./components/PathfindingVisualizer\"\r\n\r\nfunction App() {\r\n  return (\r\n    <div>\r\n      <Pathfind></Pathfind>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}